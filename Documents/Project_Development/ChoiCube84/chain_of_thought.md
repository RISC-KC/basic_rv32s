# 2025/01/26

오늘은 ALU Control 모듈을 구현하고 있다.

어제 R 타입 명령어들의 경우에 대해 alu_control 값들을 알맞게 할당해주는 과정에서, ALU에 쉬프팅 연산이 구현되어 있지 않다는 것을 발견했다. 이를 구현하고, ALU의 테스트벤치도 수정했다.

R 타입 명령어의 경우를 구현한 뒤, I 타입 명령어의 경우를 구현하고 있었다. 이 때 srai 명령어와 srli 명령어를 구분할 수 있는 유일한 방법이 imm 값을 이용하는 것이었는데, 현재 모듈 구조에서는 imm 값을 가져오고 있지 않았다. T410N 에게 건의하여 모듈 구조를 수정하여 imm 값을 받아오게 한 뒤, 구현을 마쳤다.

addi, andi 등 R 타입 명령어에 i 가 붙은 형태의 명령어들을 끝내고, 로드 명령어들에 대해 구현을 진행하고 있었다. 그런데 slli 명령어의 경우 funct3 가 001이고, lh 명령어의 경우에도 funct3 가 001 이다. 이 두 명령어를 구분할 수 있는 방법이 없는데, 두 명령어는 각각 비트 시프트 연산과 덧셈 연산을 ALU가 수행해야 한다. 쉽게 말해, 다른 동작을 해야하는 두 명령어를 구분할 방법이 없던 것이다. 이를 T410N 에게 이야기해서 모듈 구조를 instr_type 신호를 받는 대신 opcode를 직접 받는 방식으로 변경하였다.

opcode 를 직접 받는 방식으로 변경되었기 때문에, 모듈 구현 구조 자체가 크게 바뀌게 되었다. 기존의 instr_type 대신 opcode 의 case 문을 기반으로 구성하도록 수정하였다.

R 타입 명령어, imm 값으로 즉각적인 연산을 해야하는 I 타입 명령어, 로드와 점프에 각각 쓰이는 I 타입 명령어, B 타입 명령어에 대한 구현을 마쳤다. 이제 CSR 관련 명령어들을 처리해야 한다.

CSR 관련 명령어 중 A & ~B 형태의 연산을 처리해야 하는데, 현재의 ALU로는 한 번에 수행하는 건 불가능하다. 그래서 반전된 비트 신호도 같이 보내줄 수 있는지 T410N과 상의한 결과, 신호 체계가 복잡해지는 것 보다는 ALU가 전용 연산을 지원하는 편이 낫다고 결론이 났다. Abjuction 혹은 Material nonimplication 이라고 불리는 이 연산을 이제 ALU가 지원하게 되었고, 테스트벤치도 업데이트 하였다.

CSR 명령어의 opcode 가 들어왔을 때 ALU가 아무것도 하지 않아도 되는 경우가 있었다. 이 경우를 위해 ALU가 alu_op 신호로 4'b1111 신호를 받았을 때 그냥 alu_result 값을 0으로 설정해버리도록 하는 NOP 동작을 추가하였다. 테스트벤치도 업데이트 하였다.

CSR 명령어의 경우에도 ALU 가 수행해야 하는 연산을 제대로 전달하도록 구현을 완료하였다. 이로써 RV32I 명령어들에 대하여 ALU가 수행할 동작들을 할당해주는 ALU Control 모듈의 구현이 완료되었다.

이제 ALU Control 모듈을 위한 테스트벤치를 만들어야 하는데, 시간이 거의 다 되어간다... 내일 마무리 해야할 것 같다.

# 2025/01/27

오늘은 거의 하루종일 ALU 의 테스트벤치를 개선하고 이를 이용하여 ALU 를 검증하는데 대부분의 시간을 썼다... 현재까지 ALU 는 정상작동한다.

남은 시간 동안 ALU Control 모듈의 테스트벤치를 만들고 있다. 모든 종류의 인스트럭션에 대해 올바른 alu_op 신호를 도출하는지 확인하도록 노동중이다. 어깨가 아프다...

2025/01/28

ALU Control 모듈의 테스트벤치를 완성했다. 각각의 명령어에 대해 제대로 동작하는 것을 확인했고, 변경 사항이 저장된 feat/alu_control 브랜치를 develop 브랜치에 병합하기 위해 PR을 만들었다.

PR이 끝나는대로 나머지 모듈들에 대한 테스트벤치 구현을 시작할 것이다. 우선은 Instruction Decoder 모듈의 테스트벤치를 완성한 뒤, Program Coutner, PC Contoller 모듈들에 대한 테스트벤치를 구현할 것이다.

참고로 테스트벤치가 완성되면 그것을 이용하여 모듈 검증을 진행하고 있다. 나중에 따로 검증할 시간을 가지기 보다는 바로바로 검증을 마치자는 T410N 의 제안이었다.

PR은 완료되었고, develop 에서 새롭게 feat/testbenches 브랜치를 파생시켰다. 이제 Instruction Decoder 테스트벤치를 완성해야 한다. 벌써 어깨가 아프다.

Instruction Decoder 테스트벤치를 만들던 도중 내가 구현한 Instruction Decoder 의 치명적인 문제점을 발견했다. B, J 타입 명령어에서 imm 을 인코딩 하는 방식이 S, U 타입과 같을 것이라고 착각한 것이었다. B, J 타입의 경우 비트가 뒤틀려있다. 이런 기괴한 인코딩 방식을 쓰는 이유는 컴퓨터 구조 전공책에 나와있었는데, 멀티플렉서 사용에 있어 더 간단해지기 때문이었다. 대신 책에서도 나온대로, 내가 좀 더 고생을 하게 되었다... 어쨌든 오랜 노가다 끝에 괴상한 인코딩 방식을 구현했고, 이 과정에서 imm 은 32비트짜리 신호가 되었다. U 타입 명령어에서 최대 31번째 (0번째 시작) 비트 주소에 값을 저장할 수 있게 요구했기 때문이다.

그런데 여기서 문제가 발생했다. 기존에는 imm이 20비트 짜리였는데, T410N이 이렇게 zero-extension 을 그냥 해버리면 CSR 쪽이나 다른 입력 받는 곳에서 문제가 생기지 않냐는 것이었다. 이에 나는 필요한 비트 수만큼 신호를 짤라서 (대괄호를 이용한 슬라이싱) 넣어주면 상관없다고 이야기 했고, 그렇다면 Imm Gen 모듈의 기능을 Instruction Decoder 안에 자체적으로 구현하는 것이 아니냐는 질문을 받았다. 그 과정에서 Imm Gen 모듈을 보니, 입력받은 imm 값을 'sign-extension' 을 한다는 것을 알 수 있었다. 이를 통해 단순히 zero-extension 을 한 값이 아닌 12비트를 기준으로 한 sign-extension 값이 필요한 경우가 있는지 알아보았고, 그런 경우가 꽤 많았다... 그래서 나는 Imm Gen 모듈은 살려둬야한다고, 즉 이 모듈만의 기능이 있으니 그대로 두어야 한다고 주장했다. 그리고 다이어그램을 다시 보니, 이번에는 U 타입 명령어 쪽에서 문제가 생겼다. U 타입 명령어 중 auipc 에서 PC 값과 zero-extension 된 imm 값을 더해야 하는데, Instruction Decoder를 구현하는 과정에서 U 타입의 경우는 Instruction format 기준에 맞추어 '뒤쪽에' 0들을 붙였기 때문이다. 이대로 따라가다가는 sign-extension을 '하지 말아야' 할 값을 엉뚱하게 12비트 값으로 간주하고 sign-extension 을 진행해버려 오작동이 발생할 가능성이 보였고, 이를 T410N 과 상의하여 Imm Gen 을 거치는 신호와 거치지 않는 신호를 따로 빼서 MUX 를 적절히 활용하기로 하였다.

또 다시 문제가 발생했다. 사실 문제라기 보다는 일이 생긴것인데, 이번에는 ALU Control 모듈이 받는 imm 신호가 아직 업데이트 되지 않았다. 지금 ALU Control 은 입력으로 들어오는 imm 이 7비트로 들어오도록 되어있는데, 이제 imm 신호는 32비트로 통일 되었기 때문에 이 부분을 수정해주어야 했다. 가능하면 코드를 최대한 쪼끔만 고치고 싶었던 나는 한 가지 트릭을 쓰기로 했다. Instruction Decoder 에서 imm 값이 필요한 이유는 단 하나다. srli 와 srla 를 구분하기 위함인데, 이 둘을 구분하기 위해서 실질적으로는 비트 하나만 확인하면 된다. 그 비트를 입력받는 방식으로 모듈을 수정하였다. 그리고 이는 funct7 에도 해당되는 내용이어서, 이 부분도 비슷하게 수정했다.

ALU Control 모듈과 테스트 벤치를 수정한 이후에는 T410N 이 수정한 다이어그램에 맞추어 PC Controller 모듈이 Exception Detector 가 보낸 trapped 신호에 따라 PC 값을 적절히 변경하도록 수정하였고, 테스트벤치도 구현하여 검증을 완료했다.

# 2025/01/29

오늘은 어제 한꺼번에 너무 많은 일을 했는지 피곤해서 저녁 먹기 전까지는 거의 잠만 잤다. 그래서 아무것도 하지 못했었다...

제일 먼저 할 일은 Program Counter 의 테스트벤치를 구현하는 일이었다. 이 과정에서 timescale 문구를 사용하게 되었고, 다른 테스트 벤치에도 넣어주었다.

이제 현 시점에서 남은 건 Register File 의 테스트벤치 뿐이다. 이것만 구현하면 현재 구현된 6개의 모듈에 대한 모든 테스트벤치 제작 및 검증이 완료된다.

테스트벤치를 만들던 도중에 write_reg 와 reg_write 변수명이 헷갈린다는 걸 발견했다. 그래서 reg_write 신호의 이름을 write_enable 로 바꿨다.

드디어 Register File 의 테스트벤치를 완성했다! 이제 feat/testbenches -> develop 합병 이후 develop -> main 합병을 정말 오래간만에 한 번 수행할 것이다.

합병이 드디어 완료되었다! 이제 더 이상 Naver Mybox 에 일지를 올리지 않고 git 을 이용해 수정할 수 있게 되었다.

# 2025/01/30

오늘도 조금 늦긴 했지만 오전 11시 전에는 사지방에 내려와 레드불 한 캔과 함께 작업을 시작하게 되었다.

우선 이 일지를 git 에 저장하기 위해 docs 브랜치를 기반으로 devlog 브랜치를 만들었고, 여기에 내 일지 내용을 저장해서 커밋을 푸시 한 뒤, 이를 docs 에 병합하는 PR 을 만드는 방식으로 일지 관리를 할 것이다.

이제까지 6개의 모듈을 만들었고 이제 Imm Gen (Immediate Generator) 모듈을 만들 것이다. 이 모듈의 역할은 특정 명령어 타입의 imm 값을 sign-extension 하는 것이다.

구현을 진행하던 도중 갑자기 T410N 과 imm 신호를 32비트로 하는 것이 맞는지에 대한 토의가 시작되었다, 그 과정에서 J 타입 명령어도 sign-extension 을 해야한다는 사실을 발견했고, Imm Gen 모듈은 opcode 를 받아 현재 들어온 imm 값이 몇 비트짜리 값인지 알아내야 하는 방식으로 설계해야 하는 것으로 결론을 지었다.

그래서 만들었던 Imm Gen 모듈을 수정하려고 보니, opcode 를 이용해 case 문을 만들어야 했다. 이 때 각 상수가 무슨 값인지 일일히 찾는 것이 힘들어서 헤더 파일을 만들기로 했다.

modules 폴더 안에 headers 라는 폴더를 만들고, 각 opcode 의 값을 담은 상수들을 선언하였다. 이를 이용하여 지금 만들고 있는 Imm Gen 모듈 뿐만 아니라 ALU Control 같은 다른 모듈들도 리팩토링 할 수 있다.

문제는 ALU Control 모듈을 리팩토링 할 때 생겼다. ALU Control 에서 저장 명령어들에 대해 ALU 에게 덧셈을 수행하도록 지시하는 부분을 빼먹은 것이다! 이 부분은 잘 기억해뒀다가 반영해야겠다.

다시 Imm Gen 모듈을 구현하려고 했는데, 아직 imm 신호를 32비트로 하는 것이 맞는지에 대한 이야기가 끝나지 않았었다. 긴 토의의 결과, imm 신호를 20비트로 하는 것과 32비트로 하는 것 모두 작동자체는 정상적으로 이루어지며, 20비트로의 전환에 대한 것은 나중에 진행하기로 했다.

이제 진짜로 다시 Imm Gen 모듈로 돌아와서, 모듈 구현을 마치고 테스트벤치로 검증까지 마쳤다. feat/immediate_generator -> develop 으로의 병합까지 마쳤다.

To be continued...