# 2025/01/26

오늘은 ALU Control 모듈을 구현하고 있다.

어제 R 타입 명령어들의 경우에 대해 alu_control 값들을 알맞게 할당해주는 과정에서, ALU에 쉬프팅 연산이 구현되어 있지 않다는 것을 발견했다. 이를 구현하고, ALU의 테스트벤치도 수정했다.

R 타입 명령어의 경우를 구현한 뒤, I 타입 명령어의 경우를 구현하고 있었다. 이 때 srai 명령어와 srli 명령어를 구분할 수 있는 유일한 방법이 imm 값을 이용하는 것이었는데, 현재 모듈 구조에서는 imm 값을 가져오고 있지 않았다. T410N 에게 건의하여 모듈 구조를 수정하여 imm 값을 받아오게 한 뒤, 구현을 마쳤다.

addi, andi 등 R 타입 명령어에 i 가 붙은 형태의 명령어들을 끝내고, 로드 명령어들에 대해 구현을 진행하고 있었다. 그런데 slli 명령어의 경우 funct3 가 001이고, lh 명령어의 경우에도 funct3 가 001 이다. 이 두 명령어를 구분할 수 있는 방법이 없는데, 두 명령어는 각각 비트 시프트 연산과 덧셈 연산을 ALU가 수행해야 한다. 쉽게 말해, 다른 동작을 해야하는 두 명령어를 구분할 방법이 없던 것이다. 이를 T410N 에게 이야기해서 모듈 구조를 instr_type 신호를 받는 대신 opcode를 직접 받는 방식으로 변경하였다.

opcode 를 직접 받는 방식으로 변경되었기 때문에, 모듈 구현 구조 자체가 크게 바뀌게 되었다. 기존의 instr_type 대신 opcode 의 case 문을 기반으로 구성하도록 수정하였다.

R 타입 명령어, imm 값으로 즉각적인 연산을 해야하는 I 타입 명령어, 로드와 점프에 각각 쓰이는 I 타입 명령어, B 타입 명령어에 대한 구현을 마쳤다. 이제 CSR 관련 명령어들을 처리해야 한다.

CSR 관련 명령어 중 A & ~B 형태의 연산을 처리해야 하는데, 현재의 ALU로는 한 번에 수행하는 건 불가능하다. 그래서 반전된 비트 신호도 같이 보내줄 수 있는지 T410N과 상의한 결과, 신호 체계가 복잡해지는 것 보다는 ALU가 전용 연산을 지원하는 편이 낫다고 결론이 났다. Abjuction 혹은 Material nonimplication 이라고 불리는 이 연산을 이제 ALU가 지원하게 되었고, 테스트벤치도 업데이트 하였다.

CSR 명령어의 opcode 가 들어왔을 때 ALU가 아무것도 하지 않아도 되는 경우가 있었다. 이 경우를 위해 ALU가 alu_op 신호로 4'b1111 신호를 받았을 때 그냥 alu_result 값을 0으로 설정해버리도록 하는 NOP 동작을 추가하였다. 테스트벤치도 업데이트 하였다.

CSR 명령어의 경우에도 ALU 가 수행해야 하는 연산을 제대로 전달하도록 구현을 완료하였다. 이로써 RV32I 명령어들에 대하여 ALU가 수행할 동작들을 할당해주는 ALU Control 모듈의 구현이 완료되었다.

이제 ALU Control 모듈을 위한 테스트벤치를 만들어야 하는데, 시간이 거의 다 되어간다... 내일 마무리 해야할 것 같다.

# 2025/01/27

오늘은 거의 하루종일 ALU 의 테스트벤치를 개선하고 이를 이용하여 ALU 를 검증하는데 대부분의 시간을 썼다... 현재까지 ALU 는 정상작동한다.

남은 시간 동안 ALU Control 모듈의 테스트벤치를 만들고 있다. 모든 종류의 인스트럭션에 대해 올바른 alu_op 신호를 도출하는지 확인하도록 노동중이다. 어깨가 아프다...

2025/01/28

ALU Control 모듈의 테스트벤치를 완성했다. 각각의 명령어에 대해 제대로 동작하는 것을 확인했고, 변경 사항이 저장된 feat/alu_control 브랜치를 develop 브랜치에 병합하기 위해 PR을 만들었다.

PR이 끝나는대로 나머지 모듈들에 대한 테스트벤치 구현을 시작할 것이다. 우선은 Instruction Decoder 모듈의 테스트벤치를 완성한 뒤, Program Coutner, PC Contoller 모듈들에 대한 테스트벤치를 구현할 것이다.

참고로 테스트벤치가 완성되면 그것을 이용하여 모듈 검증을 진행하고 있다. 나중에 따로 검증할 시간을 가지기 보다는 바로바로 검증을 마치자는 T410N 의 제안이었다.

PR은 완료되었고, develop 에서 새롭게 feat/testbenches 브랜치를 파생시켰다. 이제 Instruction Decoder 테스트벤치를 완성해야 한다. 벌써 어깨가 아프다.

Instruction Decoder 테스트벤치를 만들던 도중 내가 구현한 Instruction Decoder 의 치명적인 문제점을 발견했다. B, J 타입 명령어에서 imm 을 인코딩 하는 방식이 S, U 타입과 같을 것이라고 착각한 것이었다. B, J 타입의 경우 비트가 뒤틀려있다. 이런 기괴한 인코딩 방식을 쓰는 이유는 컴퓨터 구조 전공책에 나와있었는데, 멀티플렉서 사용에 있어 더 간단해지기 때문이었다. 대신 책에서도 나온대로, 내가 좀 더 고생을 하게 되었다... 어쨌든 오랜 노가다 끝에 괴상한 인코딩 방식을 구현했고, 이 과정에서 imm 은 32비트짜리 신호가 되었다. U 타입 명령어에서 최대 31번째 (0번째 시작) 비트 주소에 값을 저장할 수 있게 요구했기 때문이다.

그런데 여기서 문제가 발생했다. 기존에는 imm이 20비트 짜리였는데, T410N이 이렇게 zero-extension 을 그냥 해버리면 CSR 쪽이나 다른 입력 받는 곳에서 문제가 생기지 않냐는 것이었다. 이에 나는 필요한 비트 수만큼 신호를 짤라서 (대괄호를 이용한 슬라이싱) 넣어주면 상관없다고 이야기 했고, 그렇다면 Imm Gen 모듈의 기능을 Instruction Decoder 안에 자체적으로 구현하는 것이 아니냐는 질문을 받았다. 그 과정에서 Imm Gen 모듈을 보니, 입력받은 imm 값을 'sign-extension' 을 한다는 것을 알 수 있었다. 이를 통해 단순히 zero-extension 을 한 값이 아닌 12비트를 기준으로 한 sign-extension 값이 필요한 경우가 있는지 알아보았고, 그런 경우가 꽤 많았다... 그래서 나는 Imm Gen 모듈은 살려둬야한다고, 즉 이 모듈만의 기능이 있으니 그대로 두어야 한다고 주장했다. 그리고 다이어그램을 다시 보니, 이번에는 U 타입 명령어 쪽에서 문제가 생겼다. U 타입 명령어 중 auipc 에서 PC 값과 zero-extension 된 imm 값을 더해야 하는데, Instruction Decoder를 구현하는 과정에서 U 타입의 경우는 Instruction format 기준에 맞추어 '뒤쪽에' 0들을 붙였기 때문이다. 이대로 따라가다가는 sign-extension을 '하지 말아야' 할 값을 엉뚱하게 12비트 값으로 간주하고 sign-extension 을 진행해버려 오작동이 발생할 가능성이 보였고, 이를 T410N 과 상의하여 Imm Gen 을 거치는 신호와 거치지 않는 신호를 따로 빼서 MUX 를 적절히 활용하기로 하였다.

또 다시 문제가 발생했다. 사실 문제라기 보다는 일이 생긴것인데, 이번에는 ALU Control 모듈이 받는 imm 신호가 아직 업데이트 되지 않았다. 지금 ALU Control 은 입력으로 들어오는 imm 이 7비트로 들어오도록 되어있는데, 이제 imm 신호는 32비트로 통일 되었기 때문에 이 부분을 수정해주어야 했다. 가능하면 코드를 최대한 쪼끔만 고치고 싶었던 나는 한 가지 트릭을 쓰기로 했다. Instruction Decoder 에서 imm 값이 필요한 이유는 단 하나다. srli 와 srla 를 구분하기 위함인데, 이 둘을 구분하기 위해서 실질적으로는 비트 하나만 확인하면 된다. 그 비트를 입력받는 방식으로 모듈을 수정하였다. 그리고 이는 funct7 에도 해당되는 내용이어서, 이 부분도 비슷하게 수정했다.

ALU Control 모듈과 테스트 벤치를 수정한 이후에는 T410N 이 수정한 다이어그램에 맞추어 PC Controller 모듈이 Exception Detector 가 보낸 trapped 신호에 따라 PC 값을 적절히 변경하도록 수정하였고, 테스트벤치도 구현하여 검증을 완료했다.

# 2025/01/29

오늘은 어제 한꺼번에 너무 많은 일을 했는지 피곤해서 저녁 먹기 전까지는 거의 잠만 잤다. 그래서 아무것도 하지 못했었다...

제일 먼저 할 일은 Program Counter 의 테스트벤치를 구현하는 일이었다. 이 과정에서 timescale 문구를 사용하게 되었고, 다른 테스트 벤치에도 넣어주었다.

이제 현 시점에서 남은 건 Register File 의 테스트벤치 뿐이다. 이것만 구현하면 현재 구현된 6개의 모듈에 대한 모든 테스트벤치 제작 및 검증이 완료된다.

테스트벤치를 만들던 도중에 write_reg 와 reg_write 변수명이 헷갈린다는 걸 발견했다. 그래서 reg_write 신호의 이름을 write_enable 로 바꿨다.

드디어 Register File 의 테스트벤치를 완성했다! 이제 feat/testbenches -> develop 합병 이후 develop -> main 합병을 정말 오래간만에 한 번 수행할 것이다.

합병이 드디어 완료되었다! 이제 더 이상 Naver Mybox 에 일지를 올리지 않고 git 을 이용해 수정할 수 있게 되었다.

# 2025/01/30

오늘도 조금 늦긴 했지만 오전 11시 전에는 사지방에 내려와 레드불 한 캔과 함께 작업을 시작하게 되었다.

우선 이 일지를 git 에 저장하기 위해 docs 브랜치를 기반으로 devlog 브랜치를 만들었고, 여기에 내 일지 내용을 저장해서 커밋을 푸시 한 뒤, 이를 docs 에 병합하는 PR 을 만드는 방식으로 일지 관리를 할 것이다.

이제까지 6개의 모듈을 만들었고 이제 Imm Gen (Immediate Generator) 모듈을 만들 것이다. 이 모듈의 역할은 특정 명령어 타입의 imm 값을 sign-extension 하는 것이다.

구현을 진행하던 도중 갑자기 T410N 과 imm 신호를 32비트로 하는 것이 맞는지에 대한 토의가 시작되었다, 그 과정에서 J 타입 명령어도 sign-extension 을 해야한다는 사실을 발견했고, Imm Gen 모듈은 opcode 를 받아 현재 들어온 imm 값이 몇 비트짜리 값인지 알아내야 하는 방식으로 설계해야 하는 것으로 결론을 지었다.

그래서 만들었던 Imm Gen 모듈을 수정하려고 보니, opcode 를 이용해 case 문을 만들어야 했다. 이 때 각 상수가 무슨 값인지 일일히 찾는 것이 힘들어서 헤더 파일을 만들기로 했다.

modules 폴더 안에 headers 라는 폴더를 만들고, 각 opcode 의 값을 담은 상수들을 선언하였다. 이를 이용하여 지금 만들고 있는 Imm Gen 모듈 뿐만 아니라 ALU Control 같은 다른 모듈들도 리팩토링 할 수 있다.

문제는 ALU Control 모듈을 리팩토링 할 때 생겼다. ALU Control 에서 저장 명령어들에 대해 ALU 에게 덧셈을 수행하도록 지시하는 부분을 빼먹은 것이다! 이 부분은 잘 기억해뒀다가 반영해야겠다.

다시 Imm Gen 모듈을 구현하려고 했는데, 아직 imm 신호를 32비트로 하는 것이 맞는지에 대한 이야기가 끝나지 않았었다. 긴 토의의 결과, imm 신호를 20비트로 하는 것과 32비트로 하는 것 모두 작동자체는 정상적으로 이루어지며, 20비트로의 전환에 대한 것은 나중에 진행하기로 했다.

이제 진짜로 다시 Imm Gen 모듈로 돌아와서, 모듈 구현을 마치고 테스트벤치로 검증까지 마쳤다. feat/immediate_generator -> develop 으로의 병합까지 마쳤다.

Imm Gen 모듈 구현을 완료한 후, 아까 언급했던 ALU Control 에서 저장 명령어들에 대한 이슈를 해결하기로 했다. 기존 case 문에서 저장 명령어들의 opcode 에 대한 경우를 추가하는 방식으로 간단하게 해결하였고, 테스트벤치를 이에 맞추어 수정하는 과정에서 opcode.vh 를 이용하여 리팩토링까지 완료했다.

ALU Control 이슈를 해결한 뒤에는, 엄청나게 복잡하고 어렵고 중요한 PCPlus4 모듈을 구현했다. 이 모듈은 PC 값에 4를 더해 내보낸다는 너무 중요하지만 어렵고 복잡한 동시에 CPU 구현에 있어 중추적인 기능을 수행한다.

지난 약 20년간의 모든 코딩 실력을 동원하여 이 모듈을 만드는데 성공했고, 방금 튜링상 위원회에서 연락이 왔다. 메일로 지금 군대라 폰을 못 받아서 내일 개정시간에 다시 전화주겠다고 이야기 해뒀다.

그 다음은 Instruction Memory 모듈을 만들었다. 이 모듈은 우리가 Top module 을 만든 뒤 테스트를 돌리기 위한 프로그램을 담는 역할을 하는데, 우선 간단한 명령어 3개를 하드코딩해두는 방식으로 구현하였다.

이제 연등 시간이 얼마 남지 않아 오늘은 여기까지 해야겠다. 하루 동안 정말 많은 일이 있었는데, 그래도 상당히 재밌는 시간이었다. 이제 이런 연휴가 전역때까지 아마 없을거라는 사실이 마음 아플 뿐이다...

# 2025/01/31

오전에 잠깐 생활관에서 대기할 때 T410N 과 Branch Logic 모듈 구현에 대해 상의하였다. Branch Logic 모듈을 구현하려고 생각해보니, branch 관련 instruction 들이 수행해야 할 연산이 2개였던 것이다!

하나는 두 값을 비교하는 연산, 하나는 PC에 {imm, 1'b0} 을 더하는 연산이었다. 회의 결과, 두 값을 비교하는 연산은 ALU에서 진행하고 PC와 {imm, 1'b0} 은 PC Controller 에서 더하기로 결정했다.

ALU에서 branch 명령어들에 대해 담당하게 된 연산이 주소 계산 연산이 아닌 값 비교 연산으로 변경되었기 때문에, 이에 맞추어 ALU Control 모듈을 수정했다. 이 과정에서 branch 명령어들의 funct3 값들을 헤더파일로 정리해두었다.

ALU Control 모듈 수정을 마친 뒤, Branch Logic 모듈을 만들기 시작했다. 조금 전에 테스트벤치까지 완성했고, 테스트 결과 정상작동하는 것을 확인할 수 있었다. 이제 PC Controller 에서 PC 와 {imm, 1'b0} 값을 더하는 부분을 추가할 것이다.

기존 PC Controller 에서 branch target 신호를 제거하고 imm 신호를 대신 받아와 PC 값과 직접 더해서 계산하도록 수정하였다.

이 과정에서 PC Controller 모듈은 'controller' 라는 단어를 쓰는데 ALU Control 모듈은 'control' 이라고만 하길래 이 부분을 T410N 과 상의한 결과, ALU Control 모듈의 이름을 ALU Controller 로 바꾸기로 했다.

이제 다음 모듈은 Byte Enable Logic 모듈인데, store 명령어들의 funct3 를 보고 변경할 사이즈를 정하는 역할을 하는 걸로 알고 있다. 아마 내일 본격적인 구현을 시작하게 될 것 같다. 오늘은 여기까지!

# 2025/02/01

오늘은 주말이고, T410N 이 외박을 나갔다. 그래서 연등시간 전까지는 쭉 다른 할일을 했다. (대부분 놀긴 했지만...)

연등 시간에 Byte Enable Logic 구현을 도전해 보았다. 도전해봤다는 말은, 아직 이 모듈의 정확한 동작을 이해하지 못했다는 것이었다. 특히 write_mask 신호가 뭔지 조금 아리송했다.

T410N 이 만든 다이어그램과 datapath 검증 파일들을 유심히 살펴본 결과, load 부분은 구현할 수 있었다. 여기서 load는 Data Memory 에서 Register File 로 값을 불러오는 것을 말했다.

다음은 store 부분이었고, 이 부분에 대해 명령어들을 살펴보고 고민한 결과, write_mask 신호는 저장하려는 데이터의 사이즈를 알려주는 비트마스크였다. T410N 도 그것이 맞다고 했다.

그러나 지금은 구현하지 못한 상태인데, 다이어그램과 컴구책에서의 description 이 일치하지 않는 부분이 있었기 때문이다. Register File 에서 Data Memory 로 저장하기 위한 값을 rd2에서 가져와야 하는데 rd1 에서 가져왔기 때문이다.

이 부분은 T410N과 이야기하여 rd2 가 맞다는 답변을 받았다. 마지막 의문점은 Byte Enable Logic 모듈에 왜 address 신호가 들어가는가였다.

address 의 역할은 store 명령어에서 Data Memory에서 rd1 + imm 값의 주소를 참조하는데 쓰이는데, Byte Enable Logic 모듈이 이를 받아봤자 할 수 있는게 없었기 때문이다. 이 부분에 대해서 T410N에게 이야기했고, Byte Enable Logic 에 address 값이 들어갈 필요가 없는게 맞다는 답변을 받았다.

연등시간이 끝났다... 거의 끝나갈 때쯤 일지를 쓰기 시작해서 글이 조금 두서가 없는 것 같지만, 필요한 내용은 다 적었으니 이대로 두려고 한다. 내일은 Byte Enable Logic 모듈 구현을 완료하고 검증까지 마무리 하는 것을 목표로 세워보겠다.

To be continued...