# 2025/01/26

오늘은 ALU Control 모듈을 구현하고 있다.

어제 R 타입 명령어들의 경우에 대해 alu_control 값들을 알맞게 할당해주는 과정에서, ALU에 쉬프팅 연산이 구현되어 있지 않다는 것을 발견했다. 이를 구현하고, ALU의 테스트벤치도 수정했다.

R 타입 명령어의 경우를 구현한 뒤, I 타입 명령어의 경우를 구현하고 있었다. 이 때 srai 명령어와 srli 명령어를 구분할 수 있는 유일한 방법이 imm 값을 이용하는 것이었는데, 현재 모듈 구조에서는 imm 값을 가져오고 있지 않았다. KHWL 에게 건의하여 모듈 구조를 수정하여 imm 값을 받아오게 한 뒤, 구현을 마쳤다.

addi, andi 등 R 타입 명령어에 i 가 붙은 형태의 명령어들을 끝내고, 로드 명령어들에 대해 구현을 진행하고 있었다. 그런데 slli 명령어의 경우 funct3 가 001이고, lh 명령어의 경우에도 funct3 가 001 이다. 이 두 명령어를 구분할 수 있는 방법이 없는데, 두 명령어는 각각 비트 시프트 연산과 덧셈 연산을 ALU가 수행해야 한다. 쉽게 말해, 다른 동작을 해야하는 두 명령어를 구분할 방법이 없던 것이다. 이를 KHWL 에게 이야기해서 모듈 구조를 instr_type 신호를 받는 대신 opcode를 직접 받는 방식으로 변경하였다.

opcode 를 직접 받는 방식으로 변경되었기 때문에, 모듈 구현 구조 자체가 크게 바뀌게 되었다. 기존의 instr_type 대신 opcode 의 case 문을 기반으로 구성하도록 수정하였다.

R 타입 명령어, imm 값으로 즉각적인 연산을 해야하는 I 타입 명령어, 로드와 점프에 각각 쓰이는 I 타입 명령어, B 타입 명령어에 대한 구현을 마쳤다. 이제 CSR 관련 명령어들을 처리해야 한다.

CSR 관련 명령어 중 A & ~B 형태의 연산을 처리해야 하는데, 현재의 ALU로는 한 번에 수행하는 건 불가능하다. 그래서 반전된 비트 신호도 같이 보내줄 수 있는지 KHWL과 상의한 결과, 신호 체계가 복잡해지는 것 보다는 ALU가 전용 연산을 지원하는 편이 낫다고 결론이 났다. Abjuction 혹은 Material nonimplication 이라고 불리는 이 연산을 이제 ALU가 지원하게 되었고, 테스트벤치도 업데이트 하였다.

CSR 명령어의 opcode 가 들어왔을 때 ALU가 아무것도 하지 않아도 되는 경우가 있었다. 이 경우를 위해 ALU가 alu_op 신호로 4'b1111 신호를 받았을 때 그냥 alu_result 값을 0으로 설정해버리도록 하는 NOP 동작을 추가하였다. 테스트벤치도 업데이트 하였다.

CSR 명령어의 경우에도 ALU 가 수행해야 하는 연산을 제대로 전달하도록 구현을 완료하였다. 이로써 RV32I 명령어들에 대하여 ALU가 수행할 동작들을 할당해주는 ALU Control 모듈의 구현이 완료되었다.

이제 ALU Control 모듈을 위한 테스트벤치를 만들어야 하는데, 시간이 거의 다 되어간다... 내일 마무리 해야할 것 같다.

# 2025/01/27

오늘은 거의 하루종일 ALU 의 테스트벤치를 개선하고 이를 이용하여 ALU 를 검증하는데 대부분의 시간을 썼다... 현재까지 ALU 는 정상작동한다.

남은 시간 동안 ALU Control 모듈의 테스트벤치를 만들고 있다. 모든 종류의 인스트럭션에 대해 올바른 alu_op 신호를 도출하는지 확인하도록 노동중이다. 어깨가 아프다...

2025/01/28

ALU Control 모듈의 테스트벤치를 완성했다. 각각의 명령어에 대해 제대로 동작하는 것을 확인했고, 변경 사항이 저장된 feat/alu_control 브랜치를 develop 브랜치에 병합하기 위해 PR을 만들었다.

PR이 끝나는대로 나머지 모듈들에 대한 테스트벤치 구현을 시작할 것이다. 우선은 Instruction Decoder 모듈의 테스트벤치를 완성한 뒤, Program Coutner, PC Contoller 모듈들에 대한 테스트벤치를 구현할 것이다.

참고로 테스트벤치가 완성되면 그것을 이용하여 모듈 검증을 진행하고 있다. 나중에 따로 검증할 시간을 가지기 보다는 바로바로 검증을 마치자는 KHWL 의 제안이었다.

PR은 완료되었고, develop 에서 새롭게 feat/testbenches 브랜치를 파생시켰다. 이제 Instruction Decoder 테스트벤치를 완성해야 한다. 벌써 어깨가 아프다.

Instruction Decoder 테스트벤치를 만들던 도중 내가 구현한 Instruction Decoder 의 치명적인 문제점을 발견했다. B, J 타입 명령어에서 imm 을 인코딩 하는 방식이 S, U 타입과 같을 것이라고 착각한 것이었다. B, J 타입의 경우 비트가 뒤틀려있다. 이런 기괴한 인코딩 방식을 쓰는 이유는 컴퓨터 구조 전공책에 나와있었는데, 멀티플렉서 사용에 있어 더 간단해지기 때문이었다. 대신 책에서도 나온대로, 내가 좀 더 고생을 하게 되었다... 어쨌든 오랜 노가다 끝에 괴상한 인코딩 방식을 구현했고, 이 과정에서 imm 은 32비트짜리 신호가 되었다. U 타입 명령어에서 최대 31번째 (0번째 시작) 비트 주소에 값을 저장할 수 있게 요구했기 때문이다.

그런데 여기서 문제가 발생했다. 기존에는 imm이 20비트 짜리였는데, KHWL이 이렇게 zero-extension 을 그냥 해버리면 CSR 쪽이나 다른 입력 받는 곳에서 문제가 생기지 않냐는 것이었다. 이에 나는 필요한 비트 수만큼 신호를 짤라서 (대괄호를 이용한 슬라이싱) 넣어주면 상관없다고 이야기 했고, 그렇다면 Imm Gen 모듈의 기능을 Instruction Decoder 안에 자체적으로 구현하는 것이 아니냐는 질문을 받았다. 그 과정에서 Imm Gen 모듈을 보니, 입력받은 imm 값을 'sign-extension' 을 한다는 것을 알 수 있었다. 이를 통해 단순히 zero-extension 을 한 값이 아닌 12비트를 기준으로 한 sign-extension 값이 필요한 경우가 있는지 알아보았고, 그런 경우가 꽤 많았다... 그래서 나는 Imm Gen 모듈은 살려둬야한다고, 즉 이 모듈만의 기능이 있으니 그대로 두어야 한다고 주장했다. 그리고 다이어그램을 다시 보니, 이번에는 U 타입 명령어 쪽에서 문제가 생겼다. U 타입 명령어 중 auipc 에서 PC 값과 zero-extension 된 imm 값을 더해야 하는데, Instruction Decoder를 구현하는 과정에서 U 타입의 경우는 Instruction format 기준에 맞추어 '뒤쪽에' 0들을 붙였기 때문이다. 이대로 따라가다가는 sign-extension을 '하지 말아야' 할 값을 엉뚱하게 12비트 값으로 간주하고 sign-extension 을 진행해버려 오작동이 발생할 가능성이 보였고, 이를 KHWL 과 상의하여 Imm Gen 을 거치는 신호와 거치지 않는 신호를 따로 빼서 MUX 를 적절히 활용하기로 하였다.

또 다시 문제가 발생했다. 사실 문제라기 보다는 일이 생긴것인데, 이번에는 ALU Control 모듈이 받는 imm 신호가 아직 업데이트 되지 않았다. 지금 ALU Control 은 입력으로 들어오는 imm 이 7비트로 들어오도록 되어있는데, 이제 imm 신호는 32비트로 통일 되었기 때문에 이 부분을 수정해주어야 했다. 가능하면 코드를 최대한 쪼끔만 고치고 싶었던 나는 한 가지 트릭을 쓰기로 했다. Instruction Decoder 에서 imm 값이 필요한 이유는 단 하나다. srli 와 srla 를 구분하기 위함인데, 이 둘을 구분하기 위해서 실질적으로는 비트 하나만 확인하면 된다. 그 비트를 입력받는 방식으로 모듈을 수정하였다. 그리고 이는 funct7 에도 해당되는 내용이어서, 이 부분도 비슷하게 수정했다.

ALU Control 모듈과 테스트 벤치를 수정한 이후에는 KHWL 이 수정한 다이어그램에 맞추어 PC Controller 모듈이 Exception Detector 가 보낸 trapped 신호에 따라 PC 값을 적절히 변경하도록 수정하였고, 테스트벤치도 구현하여 검증을 완료했다.

# 2025/01/29

오늘은 어제 한꺼번에 너무 많은 일을 했는지 피곤해서 저녁 먹기 전까지는 거의 잠만 잤다. 그래서 아무것도 하지 못했었다...

제일 먼저 할 일은 Program Counter 의 테스트벤치를 구현하는 일이었다. 이 과정에서 timescale 문구를 사용하게 되었고, 다른 테스트 벤치에도 넣어주었다.

이제 현 시점에서 남은 건 Register File 의 테스트벤치 뿐이다. 이것만 구현하면 현재 구현된 6개의 모듈에 대한 모든 테스트벤치 제작 및 검증이 완료된다.

테스트벤치를 만들던 도중에 write_reg 와 reg_write 변수명이 헷갈린다는 걸 발견했다. 그래서 reg_write 신호의 이름을 write_enable 로 바꿨다.

드디어 Register File 의 테스트벤치를 완성했다! 이제 feat/testbenches -> develop 합병 이후 develop -> main 합병을 정말 오래간만에 한 번 수행할 것이다.

합병이 드디어 완료되었다! 이제 더 이상 Naver Mybox 에 일지를 올리지 않고 git 을 이용해 수정할 수 있게 되었다.

# 2025/01/30

오늘도 조금 늦긴 했지만 오전 11시 전에는 사지방에 내려와 레드불 한 캔과 함께 작업을 시작하게 되었다.

우선 이 일지를 git 에 저장하기 위해 docs 브랜치를 기반으로 devlog 브랜치를 만들었고, 여기에 내 일지 내용을 저장해서 커밋을 푸시 한 뒤, 이를 docs 에 병합하는 PR 을 만드는 방식으로 일지 관리를 할 것이다.

이제까지 6개의 모듈을 만들었고 이제 Imm Gen (Immediate Generator) 모듈을 만들 것이다. 이 모듈의 역할은 특정 명령어 타입의 imm 값을 sign-extension 하는 것이다.

구현을 진행하던 도중 갑자기 KHWL 과 imm 신호를 32비트로 하는 것이 맞는지에 대한 토의가 시작되었다, 그 과정에서 J 타입 명령어도 sign-extension 을 해야한다는 사실을 발견했고, Imm Gen 모듈은 opcode 를 받아 현재 들어온 imm 값이 몇 비트짜리 값인지 알아내야 하는 방식으로 설계해야 하는 것으로 결론을 지었다.

그래서 만들었던 Imm Gen 모듈을 수정하려고 보니, opcode 를 이용해 case 문을 만들어야 했다. 이 때 각 상수가 무슨 값인지 일일히 찾는 것이 힘들어서 헤더 파일을 만들기로 했다.

modules 폴더 안에 headers 라는 폴더를 만들고, 각 opcode 의 값을 담은 상수들을 선언하였다. 이를 이용하여 지금 만들고 있는 Imm Gen 모듈 뿐만 아니라 ALU Control 같은 다른 모듈들도 리팩토링 할 수 있다.

문제는 ALU Control 모듈을 리팩토링 할 때 생겼다. ALU Control 에서 저장 명령어들에 대해 ALU 에게 덧셈을 수행하도록 지시하는 부분을 빼먹은 것이다! 이 부분은 잘 기억해뒀다가 반영해야겠다.

다시 Imm Gen 모듈을 구현하려고 했는데, 아직 imm 신호를 32비트로 하는 것이 맞는지에 대한 이야기가 끝나지 않았었다. 긴 토의의 결과, imm 신호를 20비트로 하는 것과 32비트로 하는 것 모두 작동자체는 정상적으로 이루어지며, 20비트로의 전환에 대한 것은 나중에 진행하기로 했다.

이제 진짜로 다시 Imm Gen 모듈로 돌아와서, 모듈 구현을 마치고 테스트벤치로 검증까지 마쳤다. feat/immediate_generator -> develop 으로의 병합까지 마쳤다.

Imm Gen 모듈 구현을 완료한 후, 아까 언급했던 ALU Control 에서 저장 명령어들에 대한 이슈를 해결하기로 했다. 기존 case 문에서 저장 명령어들의 opcode 에 대한 경우를 추가하는 방식으로 간단하게 해결하였고, 테스트벤치를 이에 맞추어 수정하는 과정에서 opcode.vh 를 이용하여 리팩토링까지 완료했다.

ALU Control 이슈를 해결한 뒤에는, 엄청나게 복잡하고 어렵고 중요한 PCPlus4 모듈을 구현했다. 이 모듈은 PC 값에 4를 더해 내보낸다는 너무 중요하지만 어렵고 복잡한 동시에 CPU 구현에 있어 중추적인 기능을 수행한다.

지난 약 20년간의 모든 코딩 실력을 동원하여 이 모듈을 만드는데 성공했고, 방금 튜링상 위원회에서 연락이 왔다. 메일로 지금 군대라 폰을 못 받아서 내일 개정시간에 다시 전화주겠다고 이야기 해뒀다.

그 다음은 Instruction Memory 모듈을 만들었다. 이 모듈은 우리가 Top module 을 만든 뒤 테스트를 돌리기 위한 프로그램을 담는 역할을 하는데, 우선 간단한 명령어 3개를 하드코딩해두는 방식으로 구현하였다.

이제 연등 시간이 얼마 남지 않아 오늘은 여기까지 해야겠다. 하루 동안 정말 많은 일이 있었는데, 그래도 상당히 재밌는 시간이었다. 이제 이런 연휴가 전역때까지 아마 없을거라는 사실이 마음 아플 뿐이다...

# 2025/01/31

오전에 잠깐 생활관에서 대기할 때 KHWL 과 Branch Logic 모듈 구현에 대해 상의하였다. Branch Logic 모듈을 구현하려고 생각해보니, branch 관련 instruction 들이 수행해야 할 연산이 2개였던 것이다!

하나는 두 값을 비교하는 연산, 하나는 PC에 {imm, 1'b0} 을 더하는 연산이었다. 회의 결과, 두 값을 비교하는 연산은 ALU에서 진행하고 PC와 {imm, 1'b0} 은 PC Controller 에서 더하기로 결정했다.

ALU에서 branch 명령어들에 대해 담당하게 된 연산이 주소 계산 연산이 아닌 값 비교 연산으로 변경되었기 때문에, 이에 맞추어 ALU Control 모듈을 수정했다. 이 과정에서 branch 명령어들의 funct3 값들을 헤더파일로 정리해두었다.

ALU Control 모듈 수정을 마친 뒤, Branch Logic 모듈을 만들기 시작했다. 조금 전에 테스트벤치까지 완성했고, 테스트 결과 정상작동하는 것을 확인할 수 있었다. 이제 PC Controller 에서 PC 와 {imm, 1'b0} 값을 더하는 부분을 추가할 것이다.

기존 PC Controller 에서 branch target 신호를 제거하고 imm 신호를 대신 받아와 PC 값과 직접 더해서 계산하도록 수정하였다.

이 과정에서 PC Controller 모듈은 'controller' 라는 단어를 쓰는데 ALU Control 모듈은 'control' 이라고만 하길래 이 부분을 KHWL 과 상의한 결과, ALU Control 모듈의 이름을 ALU Controller 로 바꾸기로 했다.

이제 다음 모듈은 Byte Enable Logic 모듈인데, store 명령어들의 funct3 를 보고 변경할 사이즈를 정하는 역할을 하는 걸로 알고 있다. 아마 내일 본격적인 구현을 시작하게 될 것 같다. 오늘은 여기까지!

# 2025/02/01

오늘은 주말이고, KHWL 이 외박을 나갔다. 그래서 연등시간 전까지는 쭉 다른 할일을 했다. (대부분 놀긴 했지만...)

연등 시간에 Byte Enable Logic 구현을 도전해 보았다. 도전해봤다는 말은, 아직 이 모듈의 정확한 동작을 이해하지 못했다는 것이었다. 특히 write_mask 신호가 뭔지 조금 아리송했다.

KHWL 이 만든 다이어그램과 datapath 검증 파일들을 유심히 살펴본 결과, load 부분은 구현할 수 있었다. 여기서 load는 Data Memory 에서 Register File 로 값을 불러오는 것을 말했다.

다음은 store 부분이었고, 이 부분에 대해 명령어들을 살펴보고 고민한 결과, write_mask 신호는 저장하려는 데이터의 사이즈를 알려주는 비트마스크였다. KHWL 도 그것이 맞다고 했다.

그러나 지금은 구현하지 못한 상태인데, 다이어그램과 컴구책에서의 description 이 일치하지 않는 부분이 있었기 때문이다. Register File 에서 Data Memory 로 저장하기 위한 값을 rd2에서 가져와야 하는데 rd1 에서 가져왔기 때문이다.

이 부분은 KHWL과 이야기하여 rd2 가 맞다는 답변을 받았다. 마지막 의문점은 Byte Enable Logic 모듈에 왜 address 신호가 들어가는가였다.

address 의 역할은 store 명령어에서 Data Memory에서 rd1 + imm 값의 주소를 참조하는데 쓰이는데, Byte Enable Logic 모듈이 이를 받아봤자 할 수 있는게 없었기 때문이다. 이 부분에 대해서 KHWL에게 이야기했고, Byte Enable Logic 에 address 값이 들어갈 필요가 없는게 맞다는 답변을 받았다.

연등시간이 끝났다... 거의 끝나갈 때쯤 일지를 쓰기 시작해서 글이 조금 두서가 없는 것 같지만, 필요한 내용은 다 적었으니 이대로 두려고 한다. 내일은 Byte Enable Logic 모듈 구현을 완료하고 검증까지 마무리 하는 것을 목표로 세워보겠다.

# 2025/02/02 ~ 2025/02/03

이틀간 연등 시간 내내 Byte Enable Logic 의 구현 방식에 대해 토론을 하다가 당일에는 일지를 전혀 쓰지 못했다... 지금 대신 쓰려고 한다.

Byte Enable Logic 을 설계하는 과정에서 들었던 가장 처음 들었던 의문은 address 신호가 왜 Byte Enable Logic 에 필요한가였다. KHWL 과 상의한 결과 Register File 의 값을 Data Memory 에 store 하는 과정에서 byte 나 halfword 의 경우 저장하려는 word 내부에서 저장하고 싶은 정확한 위치를 알아내기 위해서 address 값이 필요하다는 걸 알게되었다.

이를 바탕으로 구현을 하던 도중, KHWL 으로부터 데이터를 왜 굳이 변형하여 Data Memory 쪽으로 보내는가에 대한 질문을 받았다. 여기서 데이터를 변형한다는 것은, byte 의 경우 데이터의 하위 8비트를 [31:24], [23:16], [15:8] 영역으로 복사하고, halfword 의 경우 데이터의 하위 16비트를 상위 16비트에 복사하는 것을 의미한다. 이렇게 구현한 이유는 마스킹을 쉽게 적용하기 위해서였다. 내가 이해한 write_mask 를 이용한 데이터 저장 과정에서는 해당 워드에 저장된 원본 데이터에 write_mask 의 반전 마스크를 and 연산으로 씌워서 저장하고자 하는 영역을 비우고, 변형된 데이터와 write_mask 를 and 를 씌워서 데이터 위치를 정렬하고, 이 둘을 or 연산으로 합친 값을 저장하는 것이었다. 만약 데이터를 이렇게 변형하지 않았더라면 Data Memory 에서 마스크를 보고 조건문을 이용하여 데이터 위치를 옮기는 역할을 수행해야하는데, 하드웨어로 구현한다고 생각했을 때 비트 복사를 이용한 데이터 변형 방식이 더 효율적이라고 생각했기 때문이다. KHWL 은 데이터 변형에 대한 아이디어에는 최종적으로 동의했지만, write_mask 의 일반적인 규격은 4비트였고 이 부분은 내가 수용하여 수정하였다.

논의는 이렇게 종료되었고 구현은 완료하였으나, 이를 일지에 적지 못했다.

# 2025/02/04

그래서 오늘 연등 시간의 대부분은 논의의 내용을 기억해내며 어제와 그제의 일지를 적는데 투자했다. 일지 작성도 얼추 마무리됐고, feat/byte_enable_logic -> develop 으로 merge를 하는 PR 도 만들었으니 이제 Jump Address Aligner 모듈을 구현해봐야겠다.

KHWL에게 전해들은 바로는 Jump Address Aligner 모듈은 jal 혹은 jalr 명령어에서 새로운 명령어 주소로 점프할 때 인스트럭션의 주소는 4의 배수여야하기 때문에 뒤의 2개의 비트를 강제로 0으로 만들어리는 역할을 한다고 들었다.

그런데 여기서 의문이 생겼다. 사용자가 프로그램을 잘못 설계한 것이 아니라면 4의 배수가 아니도록 설계될 수가 없을 것 같은데, 만약 그런 경우는 강제로 4의 배수로 만들기 보다는 Trap 으로 처리해야 하는 것이 아닌가 궁금해졌다.

오늘은 사정상 KHWL 이 같이 개발을 진행할 수 없어 내일 물어보고 진행해야 할 것 같다. 남은 시간에는 다른 모듈을 건드려보려고 했는데, KHWL 이 잠깐와서 모든 RV32I, Zicsr, Zifencei, mret 명령어에 대한 정보가 적힌 Cheat sheet 를 전해주고 갔다!

온김에 방금 문제를 물어본 뒤, 같이 공식 매뉴얼을 확인해봤는데, jal 명령어와 jalr 명령어 모두 입력된 주소가 4의 배수가 아니면 예외를 발생시킨다고 한다. 이번에는 내 예상이 맞았던 것이다. 이를 확인한 KHWL 은 Jump Address Aligner 를 없애고 해당 예외를 처리할 수 있게 다시 구조를 설계하기로 했다.

오늘은 여기까지!

# 2025/02/05

오늘은 Exception Detector 을 만들 것이다. 역할은 말 그대로 Exception 을 잡아내는 것인데, KHWL 의 설명에 따르면 총 3가지 종류의 Exception 이 있다. EBREAK, ECALL, 그리고 주소가 제대로 정렬되지 않은 경우이다.

모듈 구현 자체는 크게 어렵지 않았다. opcode, funct3, imm 등의 값을 받아와 EBREAK 이거나 ECALL 인지 확인하고, 혹은 jal/jalr 명령어일 때 계산된 주소 값의 LSB 비트 2개가 0인지 확인하는 방식으로 간단하게 구현했다.

테스트벤치까지 모두 만들고 나서, 충격적인 소식을 들었다. 사실 Exception 이 발생하는 경우가 한 가지 더 있었고, Branch 계열 명령어에서 branch 를 take 하는 경우에 주소 미정렬도 있었던 것이다! 그런데 여기서 문제가 있었다. branch 를 take 할 때 이동하는 주소를 어디서 받아오는가 하는 것이었다.

PC + {imm, 1'b0} 값을 어딘가에서 받아와야 했는데 나는 이 연산을 따로 처리하는 모듈을 의견을 냈고, KHWL 은 PC Controller 모듈에서 받아오자고 했다. 클럭 신호로 인한 타이밍이 조금 걱정스럽긴 하지만, 최종적으로 PC Controller 모듈에서 받아오는 것으로 결론을 내리게 되었다.

이 부분은 아마 내일 추가적으로 구현하게 될 것 같다.

# 2025/02/06

그러나 내가 사지방에 너무 늦게 내려와버렸다. 벼락치기 시작이다. 우선 PC Controller 모듈이 branch_target 신호를 받는 대신 imm 신호를 받는 것으로 변경되었고 이 부분을 먼저 구현할 것이다.

아니 세상에? 이미 완성되어있었다... 생각보다 나는 부지런했던 모양이다.

어쨌든 빈손으로 돌아갈 순 없으니 Excepction Detector 모듈에 급하게 branch 관련 기능을 추가하고 커밋까지 완료했다. 남은 시간이 별로 없다. 오늘은 여기까지!

# 2025/02/07

오늘은 어제 급하게 구현한 branch 관련 기능을 검토하는 것부터 시작했다. 급하게 짠 코드 치고는 제대로 작동하고 그리 더럽지 않은 코드였다. 이대로 냅두기로 했고, 그대로 테스트벤치를 수정하여 develop 에 merge 하는 절차를 거쳤다.

이제 다음 만들 모듈을 고르고 있었는데, 처음에는 Trap Controller 를 만드려고 했었다. Exception Detector 을 막 만든 참이었기 때문에 자연스럽게 이어가면 될 것 같았다. 그러나 KHWL 에게 기능을 물어봤을 때 아직 구상하고 있는 단계라는 이야기를 들었고, 다른 모듈을 만들기로 했다.

이번에는 CSR File 을 만들어 보려고 했다. 그런데 이 역시 KHWL 으로부터 매뉴얼을 읽어야 한다는 답변을 들었다... 그리고 이제 나는 더 이상 물러설 길이 없었다.

**결국 나는 Control Unit 을 만들기로 했다. 더 이상 도망칠 수 있는 곳이 없었다.**

구현을 시작하고 가장 처음 한 것은 각 신호들의 역할을 살펴보는 것이었다. 입력으로 opcode 와 funct3 는 알겠는데 write_done 신호는 무슨 신호인지 몰라 KHWL 에게 물어본 결과, Data Cache 에서 Data Memory 로 flush? 가 일어난 이후 그 동작이 끝났음을 알리는 신호라고 설명하며, 지금 구현할 필요는 없다고 했다.

그래서 일단 2개의 입력신호만 받게 했고, 출력 신호들을 살펴보는데 csr_op 신호가 무슨 신호인지 궁금해져 역시 KHWL 에게 물어보았다. 돌아온 답변은 opcode를 기반으로한 CSR 명령어 구분이라고 했다. 그러나 CSR 명령어들의 opcode는 모두 동일했고, funct3에 따라 동작이 달라지니까 이에 대한 컨트롤제어 내용인 것 같다는 답변을 받았다.

csr_op 에 대한 내용은 납득할 수 있었는데, csr_read 와 csr_write 는 왜 필요한지 알 수 없었다. 모든 CSR 명령어들은 읽기와 쓰기가 동시에 일어났기 때문이었다. 이 부분에 KHWL 도 동의했고, 결국 그 3개의 신호중 csr_op 신호만 남게되었다.

다음은 dc_write, mem_read, mem_write 신호가 눈에 띄었다. KHWL에 따르면 dc_write 신호는 Data Cache 가 read miss 가 발생했을 때 Data Memory 에서 값을 불러오도록 지시하는 역할을 한다고 했다. 나는 Data Cache 에서 우선적으로 read/write 가 일어나고, miss 가 발생하면 그 때 캐시에서 Data Memory 에 지시를 내리는 방식을 생각했는데, 다이어그램에서는 mem_read 와 mem_write는 곧장 Data Memory 로 들어가고 있었다. KHWL에 따르면 현재 다이어그램에서는 Data Cache 의 현재 구현 방식이 내가 생각하는 방식이 아니라 read 는 Data Memory 와 Data Cache 에서 동시에 읽어나고 캐시 miss 여부에 따라 MUX로 올바른 신호를 골라주고, write 는 Data Memory 에 직접 일어나는 방식이었다. 그리고 여기서 dc_write 는 캐시 미스가 발생했을 때 Data Cache 로 하여금 Data Memory 에서 값을 불러오도록 지시하는 신호라고 한 것이었다. 나는 캐시 미스를 판단하는건 Data Cache 가 아니냐고 물었고, 맞다는 답변이 돌아왔다. 그런 다음 현재 다이어그램에서는 판단 결과를 Control Unit 에 전달해주는 신호가 없다고 말했다. 그러자 KHWL 은 캐시 미스가 발생했을 경우 신호의 이동과정을 설명해주기 시작했고, 결론적으로 dc_write 신호는 Memory Controller 에 있어야 한다고 했다. 그리하여 dc_write 신호는 더 이상 Control Unit 에 포함되지 않게 되었다.

신호 체계를 정리한 뒤, 노가다가 다시 시작되었다...

# 2025/02/08

주말이 시작되었고 사지방에 내려온 나는 어제에 이어 Control Unit을 만들기 시작했다.

case 문으로 모든 opcode 에 대해 각 output 값을 할당하기 시작했는데, KHWL 가 만든 다이어그램을 보며 어떤 신호를 전달해야 MUX 나 각 모듈들이 올바르게 동작할지 확인하며 구현했다. 구현하면서 다이어그램에서 Store 명령어들이 저장할 값을 read_reg2 가 아니라 read_reg1 에서 받아오는걸 발견했고 KHWL에게 알렸다.

R타입 명령어들까지는 순조롭게 구현이 진행되었는데, FENCE 명령어 부분에서 문제가 생겼다. 얘네가 뭐하는 건지 모르기 때문이었다. GPT로 조사한 결과, FENCE 류 명령어들은 메모리 관련 명령어들이 완료되는 것 등을 기다리게 하기 위한 명령어였다. 그래서 Control Unit 이 잠시 다른 모듈들을 멈추도록 설계할 것 같았는데, PC Controller 에는 Control Unit 에서 딱히 받는 신호가 없어보였다. 이를 KHWL에게 물어보고 답변을 대기하고 있다. 그리고 우선 무시하기로 했던 write_done 신호가 왜 필요했는지 이제는 알 것 같다. Control Unit 을 정지시켜 명령어 실행을 중단하기 위함이었다. ~~어르으으으음!!!~~ 그런데 이렇게 써보니 든 생각인데, 이 신호는 PC Controller 신호에 주는게 나아 보인다. 명령어 실행을 멈추려면 PC 값 변화를 멈춰야 한다는 건데, 그러면 Control Unit 보다는 PC_Controller 에 신호를 주는 편이 나은 것 같다... 라고 생각해보니, 지금 구현에서는 Control Unit 이 Combinational Logic 으로 설계되어있는 것 같은데, Control Unit 을 멈춰주지 않으면 현재 명령어를 계속 실행하게 될 수 있으니 이런 신호를 넣어둔 것 같다. ~~KHWL: 제 다이어그램을 믿으셔야 합니다!!~~

우선 그 부분을 확인한 뒤 CSR 명령어들에 대해 어떻게 처리해야 할지를 살펴보는데, CSR_Addr 와 CSR_WD를 선택하는 신호를 받는 MUX에서 Trap Controller로 부터 값을 받고 있었다. Trap Controller 에서 수행하는 동작중에 CSR File 에 쓰기를 하는 작업도 있다는 뜻일텐데, 어떤 instruction 에서 그런 동작을 하는지, 필요한 신호가 Control Unit 에 다 들어오고 있는지 등등을 확인하기 위해 RISC-V 공식 문서를 자세히 읽기 시작했다.

그리고 이것저것 읽다가 시간을 다 써버렸다... 솔직히 읽은 내용들이 아직 완전히 이해된 것도 아니고 정리하기도 어려운 상태인데, 딱히 내 의문점에 대한 답을 찾은 상태도 아니라 조금 심난하다... 내일 다시 이어서 읽어봐야겠다.

# 2025/02/09

대강 CSR 이 무슨 느낌인지는 알 것 같다. Control and Status Register 라는 이름이 주는 느낌 그대로 CPU 의 상태 등에 대한 정보들을 담는 특수 목적 레지스터였던 것이다.

아직 Privileged 문서를 제대로 읽어보지 않아 정확히 어떤 레지스터들이 있는지는 모르겠지만, 일단 Control Unit 구현 자체는 가능할 것 같다. 답은 간단하다. csr_address_select 신호와 csr_data_select 신호를 Trap Controller 쪽에 넘기면 되는 것이다. 애초에 Control Unit 이 관장해야 하는 신호가 아닌 것이다.

내가 이해한 것이 맞다면, CSR 에서 read/write 해야 하는 주소와 write 할 값은 평상시에는 Control Unit 에서 받아오면 되지만, Trap 이 발생했고 그 결과로 Trap Controller 에 CSR File 에 접근해야 한다면 어느쪽에서 받아와야 할지 결정하는 값은 trapped 신호라고 볼 수 있다. Trap 이 발생한 이상 Trap Controller 에서 CSR File 을 읽고쓰기를 하던 말건 Control Unit 에서 받아오는 신호, 즉 Trap 을 발생시킨 현재 명령어를 수행하려 하면 안되기 때문이다.

그리고 CSR File 에 들어가는 신호 관련해서도 한 가지 눈치챈 점이 있다. CSR File 에 들어가는 신호는 3개중 하나로 들어가게 되어있는데, 각각 raw_imm, csr_trap_write_data, alu_result 중 하나이다. csr_trap_write_data 는 Trap 이 발생했을 경우이고, alu_result 는 CSR 값과 rd1/imm 값의 연산 결과를 사용해야 할 때 였다. 여기서 문제가 생겼다. raw_imm 은 사실 접근하려는 CSR 레지스터의 주소이기 때문에 관련없는 신호가 들어가고 있던 것이다. 실제로 MUX에 들어가야 하는 신호는 rd1 신호와 rs1 신호였다. 그래서 4가지 중 한 가지를 선택하도록 해야하는 것이었다. 이 때 CSR 과 imm 을 연산하는 경우에 srcB 를 위한 MUX 에서는 Immediate Generator 에서 나온 imm 값을 사용하고 있는데, 여기서는 rs1 을 사용해야 한다. srcB 를 위한 MUX에 rs1 값도 들어가야 하는 것이다! 라고 생각하니, rd1 도 들어가야 했다. CSR과 rd1 값을 연산하는 CSR 명령어들도 있기 때문이다.

그리고 나서 살펴보니, csr_address_select 는 몰라도 csr_data_select 신호는 Control Unit 에 남아있어야 했다... 왜냐하면 rd1, rs1, alu_result 중 하나를 골라줘야 했기 때문이었다. 그걸 위한 3:1 MUX를 하나 만들고, 그 신호와 csr_trap_write_data 를 2:1 MUX 로 묶고 trapped 로 제어하는 방식을 사용해야 했던 것이다. 그렇게 생각하고 나니, KHWL 이 예전에 말했던 ALU 에 bypass 를 만드는 것이 매력적으로 다가왔다. 만약 srcB 의 bypass 를 허용하면, rd1, rs1, alu_result 신호중 선택하기 위한 3:1 MUX 를 따로 만들고 이를 위해 csr_data_select 신호를 남겨 놓을 것도 없이 ALU_Controller 만 조금 손보면 alu_result 로 신호를 통일할 수 있기 때문이다. 그리고 그 alu_result 와 csr_trap_write_data 를 2:1 MUX 로 묶은 뒤 trapped 신호로 제어하면 되는 것이었다...

우선 여기까지 KHWL 과 상의하여 내가 내린 구현 아이디어를 정리해보았고, 해당 내용을 건의해놓은 상태이다. 우선 저녁밥을 먹고와야겠다. 배고프다...

연등 시간이 시작되었다. 휴가에서 복귀한 KHWL 은 내 구현 아이디어에서 약간의 변경사항을 적용한 안에 찬성하였다. 약간의 변경사항은 rs1 신호를 src_B MUX에 추가하는 대신, src_A MUX에 추가하고 CSR 신호를 src_B MUX에 넣고, Abjunction 연산에 한해서 피연산자의 위치를 바꾸는 것이었다. 나는 이에 찬성하였고 그대로 구현하기로 하였다.

그리고 한 가지 제안을 더 했는데, 그 제안은 Exception Detector 에서 jump_target, branch_target, b_taken 신호를 받는 대신 그냥 next_pc 를 받아버리게 하는 것이었다. 어짜피 최종 주소는 next_pc 로 결정되기 때문이었다. 나는 이에 찬성하였고 그대로 구현을 수정하였다.

그리고 길고 긴 노가다가 이어졌다. ALU 와 ALU_Controller 모듈을 오랜만에 수정하는 과정에서 헤더파일을 새로 만들고 이를 적용하는 등 길고 긴 노가다가 이어졌다. 그리고 하루가 바뀐 시점에서, EBREAK/ECALL 과 CSR 명령어들에 대한 Control Unit 의 기능을 추가하는데 성공하였다. 내일은 FENCE 명령어들에 대한 처리를 하고 시간이 남는다면 테스트벤치를 만들 것이다. 아마 이 과정에서 Control Unit 의 write_done 신호가 부활하게 될 것 같다. 오늘은 여기까지!

# 2025/02/10

KWHL 과 아침에 이야기를 나눈 결과, write_done 신호는 단순히 FENCE 명령어에서만 쓰이는 것이 아니라 캐시 구조를 적용하면서 발생하는 쓰기 폭주 문제 등을 해결하기 위해 사용될 수도 있다는 결론에 도달했다. 어쨌든 구현 방식은 기존에 생각하던 것과 같다. write_done 신호가 거짓인 경우에는 모든 값을 0으로 내보내고, 아니면 기존의 구현대로 진행시키면 된다. FENCE 명령어의 경우에는 그냥 모든 신호를 0으로 보내면 된다.

그렇게 구현이 끝났고, 테스트벤치를 만들기 시작했다. 평출도 다녀오고 해서 아직 충분히 만들지 못했지만 구조는 대강 잡아서 내일이면 완성할 수 있을 것 같다.

그러고보니 write_done 신호가 PC Controller 에도 들어가야 했던 것 같던데, 그걸 깜빡하고 구현을 안했다. 내일 해야겠다... 오늘은 여기까지!

# 2025/02/11

오늘은 사지방에 8시쯤 내려왔다. 급하게 Control Unit 테스트벤치를 완성했고, 결과를 출력하여 검증을 KHWL 에게 부탁하였다. 돌아온 결과는 MUX 신호 선택 위치가 예전 다이어그램 기준으로 되어있어 수정해달라는 것이었다.

연등 시간이 시작되었고, alu_src_select.vh 파일을 수정한 뒤 다시 테스트벤치 결과를 KHWL 에게 보냈다. 이 때 KHWL 으로부터 새로운 설계 제안이 들어왔다.

Branch 명령어들은 비교 연산을 ALU 에서 수행하는데, 동시에 PC + imm 값을 알아내어 해당 명령어 위치로 이동해야 한다. 그래서 PC Controller 는 PC + imm 을 계산하는 로직을 내장하고 있는데, JAL 명령어도 PC + imm 값을 알아내어 해당 명령어 위치로 이동해야 한다. 여기서 발생한 제안인데, ALU src_A MUX 에서 PC 값을 제거하고 그냥 PC Controller 에 있는 PC + imm 로직을 재활용하자는 것이었다.

나는 이에 대해 그렇게 하면 기존에는 jump 신호로 jump 가 이루어지는지 이루어지지 않는지만 판단했던 기존과 달리 jump 신호를 세분화하여 JAL 과 JALR 명령어를 구분할 수 있게 구현을 수정해야 하는 소요가 발생함을 주장했고, 논의 결과 현재 구현을 유지하기로 했다.

지금은 우선 채점을 기다리고 있다. 채점이 끝나는대로 commit, push, merge 해야겠다. 그리고 간략화된 top module 을 만들준비가 되었으니 한번 develop -> main merge 도 해야겠다.

일단 남는 시간 동안은 캐시 공부를 좀 해야 될 것 같다. 어떻게 구현해야 할지 감도 잘 안오기 때문이다.

그렇게 캐시 공부를 하다가 CSR 부분 Control Unit 구현 관련해서 KHWL 으로부터 질문을 받았는데, CSRRW/CSRRWI 명령어에서 src_A select 신호가 00이 되어 아무것도 받지 않게 해야하는 거 아니냐고 물었다. 어짜피 src_B bypass 가 일어나기 때문에 무엇이 들어가도 상관이 없다고 했더니, 안 쓰이면 우선 0으로 초기화하는 관행을 지키자는 답변이 돌아왔다. 조건문 고치러 가야겠다...

벌써 시간이 다 되었다. 오늘은 여기까지!

# 2025/02/12

어제 밤에 KHWL 과 FENCE 명령어가 어떻게 동작해야 하는지에 대해 의논했다. 나온 결론은 다음과 같다.

FENCE 명령어들이 필요한 이유: **FENCE 명령어들의 존재의의는 프로그래머가 동시성 프로그래밍 환경에서 발생하는 race condition 을 해결해주기 위함이다.**

이를 바탕으로 현재의 싱글코어 구현에서는 그냥 Control Unit 이 FENCE 명령어일 때는 모든 신호를 0으로 뿌리는 방식의 구현을 유지하면 된다는 결론이 나왔었다.

오늘 사지방에 내려와서는, KHWL 의 검증이 완료되었기 때문에 feat/control_unit -> develop 으로의 merge 와 develop -> main 으로의 merge 를 진행하였다.

그렇게 간략화된 탑 모듈 구현을 시작하려 하는데, 갑자기 캐시 관련해서 의문이 생기기 시작했다. 캐시에서 메모리로 쓰기 작업을 큐 해두는 buffer 를 생각했었는데 현재 구현이 이를 제대로 반영하는지, 그리고 그런 buffer 를 사용하는 것이 유효한 구현 방식인지 등 여러 가지 의문점이 생겼기 때문이다.

그렇게 이래저래 검색을 하며 알아보던 사이 시간이 다 지나가 버렸다... 내일 다시 이어서 해봐야겠다. 오늘은 여기까지!

# 2025/02/13

나는 FENCE 명령어에 대해 아직 모른다. 그게 내 결론이다.

Control Unit 만들기를 마무리 하고 이제 RV32I37F 탑 모듈 만들기를 시작하려고 했는데, 아직 끝나지 않은 작업이 있었다. PC Controller 모듈에 write_done 신호를 넣어주는 것이었다.

그런데 그 작업을 하기 전에 FENCE 명령어가 실행되었을 때 캐시의 동작 등이 어떻게 구현되어야 하는지의 문제 등 다양한 것을 고민하다가 결국 미궁에 빠져버렸다. 요 며칠간 개발이 제대로 이루어지지 않는 것도 그 때문인 것 같다...

공식 매뉴얼을 열심히 뒤져본 결과, FENCE 명령어의 동작을 정확히 이해하기 위해서는 RVWMO 에 대해 알아야 했다. 여러 개의 스레드가 동시에 메모리를 사용하려고 할 때 이 명령어들을 '정렬' 하는 방식에 대한 표준인데, FENCE 가 여기에 관련이 있는식으로 적혀있었다.

우선 이 부분은 KHWL 에게 연구를 맡기고 나중에 설명을 자세히 듣기로 했다. 나는 우선 PC Controller 가 write_done 신호도 받도록 구현을 수정하고 검증한 뒤, RV32I37F 탑 모듈 구현을 할 것이다.

이제 연등 종료시간이다. 우선 PC Controller 의 수정과 PR 은 완료했고, 내일부터 RV32I37F 제작에 돌입해야겠다. 오늘은 여기까지!

# 2025/02/14

연등 시간이 시작되었다. 어제 PC Controller 수정을 완료했고, 오늘은 드디어 RV32I27F 를 만들어볼 것이다! 검증도 진행해볼 것이다.

To be continued...